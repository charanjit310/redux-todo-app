https://stackblitz.com/edit/react-wjdepp
https://randomuser.me/api/
https://jsonplaceholder.typicode.com/users
--------react-form-hook--------
npm install react-hook-form
npm install @hookform/resolvers
npm install yup
--------Redux--------------
npm install redux react-redux
npm install react-js-pagination

-------redux-devtools-extension----
npm install redux-devtools-extension



what are the parameters of creatStore()
https://blog.logrocket.com/localstorage-javascript-complete-guide/
what is helpers/history.js
null vs undefined https://stackoverflow.com/a/5076962



  // import { Storage } from "./services/storage.service";
  // const userKeyPrefix = 'users'
  // const setUser = Storage.setJSON(userKeyPrefix, { name: 'aaa' })
  // const allUsers = Storage.getJSON(userKeyPrefix)
  // console.log(allUsers);


Redux Thunk is middleware that allows action creator to return function rather than the object 
or just actions.
With the help of the redux-thunk we can pass actions creator to our dispatch() that perform 
some side3effects like API's call to server and to responses of these api calls we can dispatch other 
action creators

console.log(abc())
fucntion abc(){ console.log('something')}
clousers :- it gives proivate sapce to your variable
[a,b] =[b,a]
event loop
micro servives ? : monolethic:- this is another type
lazy loading
binear linear 
sort, map
var, let, cosnt , clousers
pass state from child to parent component ?
how javascript runs i browswers
callbacks ?
diff map vs forech
covert obj to array 
why use react 
useRef
https://dev.to/banesag/javascript-logical-operators-and-boolean-values-1l07
how to persists state  reactjs
Optional chaining (?.)
    

    const a = true
    console.log(a) // true ('a' is true)
    console.log(!a) // false ('a' is false)

    //Instead of using ternary operator use '||'
    const var1 = 0 // false value
    const var2 = var1 ? var1 : "something";
    const var3 = var1 || "something";
    console.log(!!var1) // false
    console.log(var2)   // "something"
    console.log(var3)   // "something"

    // logical NOT
    const a = true, b = false;
    console.log(!a); // false
    console.log(!b); // true
    ! evaluates to true if the operand is false and vice-versa.

    // logical OR
    const a = true, b = false, c = 4;
    console.log(a || b); // true
    console.log(b || b); // false
    console.log((c>2) || (c<2)); // true
    || evaluates to true if either of the operands is true. And evaluates to false If both operands are false,

    // logical AND
    const a = true, b = false; c = 4;
    console.log(a && a); // true
    console.log(a && b);  // false
    console.log((c > 2) && (c < 2)); // false
    && evaluates to true if both the operands are true, else evaluates to false.The value returned will be the last truthy value if they are all true, but it will return the first falsy value if at least one value is false.
    another ex :- 
    {user && someFunction()} // this function run someFunction() only if 'user' is not null
    const var3 = var1 || "something"; // this will return var1 if its exists otherwise "something"

    // Double NOT (!!)
    Using double negation (!!) can help you to find if a value is truthy or falsy,
      ex:- 
        !! ‘ ’; // empty string value is false<< false
        !!“hello”; << true
        !!3; << true

    --OR--
    It converts a nonboolean to boolean value.it gives original value in form of boolean.
    (for ex, !5(5 is not true) would be false, because 5 is a true value ), 
    then boolean-inverts that so you get the original value as a boolean (so !!5 would be true, means 5 is true).
    var foo = "Hello World!";
    !foo // Result: false :- ! it evaluates to true if the operand is false and vice-versa
    !!foo // Result: true :- !! it converts any obj to boolean and gives the original value in the form of boolean

    // ?? operator:- it only checks for null or undefined.
    foo ?? bar
    would be the same as:
    foo != null ? foo : bar

    // Spread operators :- Adding array elements to an existing array
    const arr = [1, 2, 3];
    const arr2 = [...arr];

    // Rest  operators :- collapsing all remaining arguments of a function into one array
    function sum( first, ...others ) {
    for ( var i = 0; i < others.length; i++ )
        first += others[i];
        return first;
    }
    console.log(sum(1,2,3,4))// sum(1, 2, 3, 4) == 10;

    // pass direct hanldler vs handler in arrow function 
    <button onClick={() => deleteAccount()}>Delete My Account</button>
    in above code you are passing click event handler function to onclick which make call to deleteAccount function, while in below code

    <button onClick={deleteAccount}>Delete My Account</button>
    you are directly passing deleteAccount as click handler to component. you can use the first one when you want to process event object before calling deletedAccount and second one when you want directly call deleteAccount.

    useCallback() in clickHadler ??????
    
    useCallback:- useCallback is to memoize a callback itself (referential equality) between renders.
      The useCallback hook is used when you have a component in which the child is rerendering again and again without need.
      Pass an inline callback and an array of dependencies. useCallback will return a memoized version of the callback that only changes if one of the dependencies has changed.
      This is useful when passing callbacks to optimized child components that rely on reference equality to prevent unnecessary renders.
    useMemo :- allows you to memoize expensive functions so that you can avoid calling them on every render. You simple pass in a function and an array of inputs and useMemo will only recompute the memoized value when one of the inputs has changed
    useRef is to keep data between renders (updating does not fire re-rendering)
    Dependencies array:- Dependencies array for useCallback and useMemo is the state value of the component 
    React.memo :- it only re renders component when the props of component have changed


    Async Await :- 
    async and await make promises easier to write
    async makes a function return a Promise
    await makes a function wait for a Promise
    async/await allows us to write asynchronous code in a synchronous manner.
    The one thing you need to know about async functions is that; they always returns a promise.
    In the case where we explicitly return something that is not a promise, like above, the return value is 
    automatically wrapped into a resolved promise with the resolved value 

    callback functions :- is a function inside a function.
    A callback is a function passed as an argument to another function 
    This technique allows a function to call another function 
    A callback function can run after another function has finished

    clouser is a space used to create private variable.  
    what is currnet version of reactjs
    what is redux,react lifcycles, DOM

    Destructuring
      The destructuring syntax is a JavaScript expression that makes it possible to unpack VALUES from arrays, or PROPERTIES from objects, into distinct variables.
    
    Array destructuring
      const [red, yellow] = ['one', 'two'];
      console.log(red); // "one"
      console.log(yellow); // "two"

    Object destructuring
      const user = {id: 42,isVerified: true };
      const {id, isVerified} = user;
      console.log(id); // 42
      console.log(isVerified); // true

      Assigning to new variable names
        A property can be unpacked from an object and assigned to a variable with a different name than the object property.
        const o = {p: 42, q: true};
        const {p: foo, q: bar} = o;
        console.log(foo); // 42
        console.log(bar); // true


Object.keys(userData).length === 0 // checking if object is empty
----------------------------------------- objectToFormData ----------------------------
var formData = new FormData();
function objectToFormData(obj, rootName) {
    function appendFormData(data, root) {
            root = root || '';
            if (data instanceof File) {
                formData.append(root, data);
            } else if (Array.isArray(data)) {
                for (var i = 0; i < data.length; i++) {
                    appendFormData(data[i], root + '[' + i + ']');
                }
            } else if (typeof data === 'object' && data) {
                for (var key in data) {
                    if (data.hasOwnProperty(key)) {
                        if (root === '') {
                            appendFormData(data[key], key);
                        } else {
                            appendFormData(data[key], root + '[' + key + ']');
                        }
                    }
                }
            } else {
                if (data !== null && typeof data !== 'undefined') {
                    formData.append(root, data);
                }
            }
    }
    appendFormData(obj, rootName);

    return formData;
}


    const registration:any = objectToFormData(payload.registration, 'registration');